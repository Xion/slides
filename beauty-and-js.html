<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>The Beauty and the JavaScript</title>
<!-- metadata -->
<meta name="generator" content="vim" />
<meta name="version" content="S5 1.1" />
<meta name="presdate" content="20110919" />
<meta name="author" content="Karol Kuczmarski" />
<meta name="company" content="Polidea" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/default/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/default/opera.css" type="text/css" media="projection" id="operaFix" />
<!-- S5 JS -->
<script src="ui/default/slides.js" type="text/javascript"></script>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.3/jquery.min.js" type="text/javascript"></script>
</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h1>2011-08-19 @ Polidea</h1>
<h2>The Beauty and the JavaScript</h2>
</div>

</div>


<div class="presentation">

<div class="slide">
	<h1>The Beauty and the JavaScript</h1>
	<h2>The good, the bad... but mostly ugly</h2>
	<h3>Karol Kuczmarski</h3>
	<h4>Polidea</h4>
</div>


<div class="slide">
	<h1>Why JavaScript?</h1>
	<ul>
		<li>Ubiquitous programming language of the Web
		<ul>
			<li>supported by pretty much every browser <br>(Lynx notwithstanding)</li>
			<li>works by default without any plugins</li>
			<li>surprisingly efficient (Chrome's V8, Firefox' TraceMonkey)</li>
		</ul></li>
		<li>Endorsed by the Big Three:
		<ul>
			<li>Apple doesn't like Flash</li>
			<li>Google supports everything related to the Web</li>
			<li>Microsoft sees the failure of web Silverlight</li>
		</ul></li>
		<li>Not only web applications but also:
		<ul>
			<li>server-side code (<em>Node.js</em>)</li>
			<li>mobile apps (<em>PhoneGap</em>, <em>MonoTouch</em>, ...)</li>
			<li>desktop apps (Windows 8)</li>
		</ul></li>
	</ul>
	<div class="handout">
		Examples of useful web applications include LucidChart, Gmail, Prezi, Scribd and many more.
	</div>
</div>

<div class="slide">
	<h1>Why JavaScript <em>sucks</em>?</h1>
	<ul>
		<li>It wasn't designed for solutions of this scale</li>
		<li>It's very different from almost every other major language
		<ul>
			<li>No, it's not "scripting flavor of Java"</li>
		</ul></li>
		<li>Its seeming simplicity is deceptive:
		<ul>
			<li>Very easy to acquire bad habits</li>
			<li>Might be easy to pick up, but is hard to master</li>
		</ul></li>
		<li>Has quite a number of major and minor flaws</li>
	</ul>
</div>

<div class="slide">
	<h1>What can we do about it?</h1>
	<ul>
		<li>Use libraries &amp; and frameworks that hide the ugly details
		<ul>
			<li style="font-style:italic">"There is a jQuery plugin for that!"</li>
		</ul></li>
		<li>Understand (and embrace) the core language concepts:
		<ul>
			<li>Closures, class-less object model, and many more...</li>
		</ul></li>
		<li>Refrain from using the poorly designed features
		<ul>
			<li>You will see them :-)</li>
		</ul></li>
	</ul>
</div>

<div class="slide">
	<h1>The Source</h1>
	<div style="float:right; width: 45%">
		<img src="http://covers.oreilly.com/images/9780596517748/lrg.jpg" style="height: 500px"
			alt="JavaScript: The Good Parts">
	</div>
	<ul>
		<li><em>JavaScript: The Good Parts</em> by Douglas Crockford
		<ul>
			<li>Author of JSON.js library and developer of JSLint</li>
		</ul></li>
		<li>Must-read for any serious (or semi-serious) JavaScript developer</li>
		<li>Most of the concepts here are drawn from this book</li>
		<li>Despite being thin, it's <strong>not</strong> an airplane book
		<ul>
			<li>Quite "dense"</li>
			<li>Lots of code</li>
			<li>To be taken with grain of salt</li>
		</ul></li>
	</ul>
</div>


<div class="slide">
	<h1>JavaScript libraries: the two towers</h1>
	<p>Two major types of JavaScript libraries:</p>
	<ol>
		<li>Cross-browser DOM &amp; AJAX libraries:
		<ul>
			<li>jQuery, Ext.JS, Dojo, YUI, UIZE, ...</li>
		</ul></li>
		<li>Frameworks with language extensions:
		<ul>
			<li>Underscore.js, Prototype, MooTools, ...</li>
		</ul></li>
	</ol>
</div>

<div class="slide">
	<h1>Everyone* uses an AJAX/DOM library</h1>
	<ul>
		<li>...and it's almost always jQuery</li>
		<li>Functionality includes:
		<ul>
			<li>CSS-like selectors for accessing DOM elements</li>
			<li>Methods for manipulating DOM elements</li>
			<li>Event binding</li>
			<li>Simplified handling of AJAX requests</li>
			<li>Shielding against browsers' peculiarities</li>
			<li>...and many more</li>
		</ul></li>
		<li>Libraries like jQuery are one of reasons why JavaScript is sometimes called "assembler of the Web"</li>
	</ul>
	<br/>
	<small>* slightly above 50% of websites according to <a href="http://w3techs.com/technologies/overview/javascript_library/all">W3 Techs</a></small>
</div>

<div class="slide">
	<h1>With jQuery, everything is easy!...</h1>
	<pre>
&lt;script type="text/javascript"&gt;

    $(document).ready(document_ready);

    function document_ready() {
        $("#myButton").bind("mouseover", myButton_mouseover);
    }

    function myButton_mouseover() {
        $("#myButton").css("background-color", "red").fadeOut();
    }

&lt;/script&gt;
	</pre>
	<input type="button" value="Click me!" id="myButton"
		style="float:right; width: 150px; height: 30px; font-size: 20px;">
	<script type="text/javascript">
		$(document).ready(function() {
			$("#myButton").bind('mouseover', function() {
				$(this).css("background-color", "red").fadeOut('slow');
			});
		});
	</script>
</div>

<div class="slide">
	<h1>...or is it?</h1>
	<pre>
(function($) {
    $(document).ready(function() {
        for (var i = 0; i &lt; BUTTON_COUNT; ++i) {
          $("#button" + i).bind("click", (function(k) {
              return function() {
                  $.post("/rpc/foo", {index: k}, function(resp) {
                      if (resp) {
                          alert("[" + k + "] = " + resp.message);
                      }
                  });
              };
          })(i));
        }
    });
})(jQuery);
	</pre>
</div>

<div class="slide">
	<h1>"Solution": let's fix the language!</h1>
	<ul>
		<li>Frameworks like MooTools attempt to "extend" JavaScript:
		<ul>
			<li>Import classic OO concepts such as classes and inheritance</li>
			<li>Force it to be more like other languages</li>
			<li>Make PHP/Java/C#/etc. programmers feel relatively comfortable</li>
		</ul></li>
		<li>Result is artificial, at best:
		<ul>
			<li>Every framework does it in slightly different way</li>
			<li>Having "keyword" <code>inherits</code> doesn't mean we have true inheritance</li>
			<li>Interpreter will <strong>not</strong> check if we use the modified language correctly</li>
		</ul></li>
		<li><small><em>Aside</em>: What other languages actually allow you to implement <br><strong>whole programming paradigms</strong> in them?</small></li>
	</ul>
</div>


<div class="slide">
	<h1>Back to basics</h1>
	<ul>
		<li>JavaScript as a language is:
		<ul>
			<li>interpreted</li>
			<li>dynamically-typed</li>
			<li>object-oriented</li>
			<li>prototype-based</li>
		</ul></li>
		<li>JavaScript doesn't really support classes
		<ul>
			<li>Everything is just an object</li>
			<li>You cannot define new types - you can only create new objects</li>
		</ul></li>
		<li>The core concept of JavaScript's object model is <strong>prototype</strong>
		<ul>
			<li>It's not a class! <small>(but can be used to simulate inheritance)</small></li>
			<li>Prototype is a "parent" or "template" for an <em>object</em></li>
			<li>Attributes not present in object are taken from its prototype</li>
		</ul></li>
	</ul>
</div>

<div class="slide">
	<h1>Prototypes by example</h1>
	<ul>
		<li>Each JavaScript type (<code>String</code>, <code>Number</code>, <code>Array</code>, <code>Object</code>, <code>Function</code>) has a built-in, predefined prototype
		<ul>
			<li>It's used by every instance of particular type</li>
			<li>We can access it via <code>prototype</code> attribute</li>
		</ul></li>
		<li>Those prototypes can be modified like any object
		<ul>
			<li>We can, say, extend them</li>
		</ul></li>
	</ul>
	<br/>
	<pre>
String.prototype.capitalize = function() {
  var firstLetter = this.substr(0, 1).toUpperCase();
  var rest = this.substr(0, 1).toUpperCase();
  return firstLetter + rest;
}

console.log("alice".capitalize());  // "Alice"
	</pre>
	<div class="handout">
		Note that <code>Array</code> is not actually a type (since <code>typeof([]) == "object"</code>), but
		every array has a prototype of <code>Array.prototype</code>. Hence it is possible to add methods
		that will work for all arrays.
	</div>
</div>

<div class="slide">
	<h1>Function is king</h1>
	<ul>
		<li><code>function</code> is about the only structural construct in JavaScript
		<ul>
			<li>Program in JS is essentially a set of ((deeply) nested) functions</li>
		</ul></li>
		<li>Functions work as <em>first-order values</em>:
		<ul>
			<li>Can be stored in variables</li>
			<li>Can be passed as arguments to other functions</li>
			<li>Can be returned as functions' results</li>
		</ul></li>
		<li>Functions can be nested, creating <strong>closures</strong>:
		<ul>
			<li>Outside variables are "captured" within closure and can be modified...</li>
			<li>...regardless of how and when the function is actually called</li>
		</ul></li>
	</ul>
</div>

<div class="slide">
	<h1>Closures by example</h1>
	<pre>
function getMoreItems() {
    $.getJSON("/rpc/get_more", function(response) {
        var items = [];
        $.each(response.items, function(idx, val) {
            <strong>items</strong>.push("[" + val.type + "] " + val.text);
        });
        showItems(items);
    });
}
	</pre>
	<div class="handout">
		<em>Note</em>: This usage of <code>$.each</code> is roughly equivalent to the following loop:
		<pre>
for (var idx in response.items) {
    if (response.items.hasOwnProperty(idx)) {
        var val = response.items[idx];
        items.push("[" + val.type + "] " + val.text);
    }
}
		</pre>
	</div>
</div>

<div class="slide">
	<h1>One closure to rule them all</h1>
	<ul>
		<li>JavaScript closures allow for mechanisms that other languages have dedicated constructs for - including:
		<ul>
			<li>proper scoping of variables</li>
			<li>modularization</li>
			<li>encapsulation</li>
			<li>inheritance</li>
		</ul></li>
		<li>Extension frameworks use closures to simulate the concepts above</li>
	</ul>
</div>

<div class="slide">
	<h1>Variable scoping</h1>
	<ul>
		<li>By default, JavaScript variables are <strong>global</strong>
		<ul>
			<li>Yes, even those declared inside functions!</li>
		</ul></li>
		<li>We can use <code>var</code> keyword to achieve <em>function scope</em>
		<ul>
			<li>Obviously, function arguments also have function scope</li>
		</ul></li>
		<li>Common technique to avoid polluting global namespace is to use anonymous function which is immediately called</li>
	</ul>
	<br/>
	<pre>
(function($) {
  // using $ here will not conflict with
  // any outside code that uses the same symbol
})(jQuery);
	</pre>
	<div class="handout">
		Bear in mind that JavaScript has no local scope. So in the following example, both <code>x</code> and <code>y</code> share the same scope:
		<pre>
function foo(arg) {
    var x;
    if (arg > 0) {
        var y;
        // ...
    }
}
		</pre>
		Due to this, it is often suggested for all variables to be declared at the beginning of function (like in C).
	</div>
</div>

<div class="slide">
	<h1>Creating "modules"</h1>
	<ul>
		<li>JavaScript does not have equivalent of packages, assemblies or namespaces</li>
		<li>To simulate them, it is customary to group functions into objects</li>
	</ul>
	<br/>
	<pre>
var temps = {
    toCelsius: function(fahrenheit) {
        return 5/9 * (fahrenheit - 32);
    },
    toFahrenheit: function(celsius) {
        return 9/5 * celsius + 32;
    },
};

console.log("80^F is " + temps.toCelsius(80) + "^C");
	</pre>
</div>

<div class="slide">
	<h1>Hiding internals</h1>
	<ul>
		<li>By combining function scope and closures, we can create modules that hide their implementation details</li>
		<li>Again, trick is an anonymous function which is called at once</li>
	</ul>
	<br/>
	<pre>
var counter = (function() {
    var value = 0;
    return {
        increment: function(by) { value += by || 1; },
        decrement: function(by) { value -= by || 1; },
        getValue:  function()   { return value; },
    };
})();

counter.increment();
console.log("Counter's value == " + counter.getValue());
	</pre>
</div>

</div>

<div class="slide">
	<h1>Inheritance of objects</h1>
	<ul>
		<li>Due to lack of classes, 'inheritance' in JavaScript usually means creating new <em>object</em> using existing one as prototype</li>
		<li>Closures are used to hide private variables and functions</li>
	</ul>
	<br/>
	<pre>
var counterEx = (function(counter) {
   var c = {};
   c.prototype = counter;

   var precision = 2; // private "field"
   c.setPrecision = function(p) { precision = Math.max(p, 1) };
   c.print = function() {
       console.log("Counter = " + c.getValue().toFixed(precision));
   };
   return c;
})(counter);
	</pre>
	<div class="handout">
		Note how previous slide talked about creating a "module" (named <code>counter</code>) and this one uses this
		"module" as base for inheritance. That's because the distinction is moot. Both <code>counter</code> and <code>counterEx</code> are
		in fact just objects.
	</div>
</div>


<div class="slide">
	<h1>More traditional approach</h1>
	<ul>
		<li>Besides beforementioned "OOP by closures", JavaScript also offers an approach that resembles classic OO techniques
		<ul>
			<li>It is not valued highly by JS purists, though</li>
		</ul></li>
		<li>It uses a special type of function invocation: constructor call (<code>new</code> keyword)</li>
		<li>Constructor function accesses/initializes  the new object via <code>this</code> keyword</li>
		<li>Methods can be added as attributes of <code><em>ConstructorName</em>.prototype</code></li>
	</ul>
</div>

<div class="slide">
	<h1>Almost like classes!</h1>
	<pre>
function Vector2(x, y) {
    this.x = x || 0;
    this.y = y || 0;
}

Vector2.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
}
Vector2.prototype.translate = function(dx, dy) {
    this.x += dx; this.y += dy;
}
Vector2.prototype.scale = function(k) {
    this.x *= k; this.y *= k;
}

var vec = new Vector2(1, 2);
vec.scale(42);
	</pre>
</div>

<div class="slide">
	<h1>Is it bad?...</h1>
	<ul>
		<li>It works and it's simple
		<ul>
			<li>Explicit <code>new</code> also makes it more evident that an object is being created</li>
		</ul></li>
		<li>But while it's useful, this approach has some problems on its own:
		<ul>
			<li>It offers <strong>no encapsulation</strong> whatsoever</li>
			<li>Resulting object still doesn't have distinct type
			<ul>
				<li><code>typeof(new Foo())</code> equals to <code>"object"</code>, not <code>"Foo"</code></li>
			</ul></li>
			<li>The constructor function can still be called normally, i.e. without <code>new</code>
			<ul>
				<li>It will return <code>undefined</code> as result</li>
			</ul></li>
			<li><code>this</code> keyword in JS can be <strong>very</strong> misleading</li>
		</ul></li>
	</ul>
</div>

<div class="slide">
	<h1>How does <em>this</em> work?</h1>
	<ul>
		<li>Meaning of <code>this</code> depends on which function it is used in and how it was called</li>
		<li>It becomes a problem when nested functions are involved</li>
		<li>Solution: bind <code>this</code> to local variable (usually named <code>that</code>)</li>
	</ul>
	<br/>
	<pre>
Game.prototype.setupEventHandlers = function() {
    var that = this;
    $("#gamefield").bind("click", function(event) {
         var obj = that.hitTest(event);
         if (obj) obj.click();
    });
};
	</pre>
</div>

</body>
</html>
